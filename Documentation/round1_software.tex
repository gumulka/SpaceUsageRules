\section{Softwareimplementierung}
Auch wenn Anfangs eine deutliche Tendenz zu C/C++ als Programmiersprache der Wahl war, fiel durch das spätere Interesse für eine
Android Applikation die Wahl auf Java. So ist es einfach möglich einen Kern mit Algorithmen zu schreiben und diesen von den
verschiedenen Anwendungen als Bibliothek nutzen zu lassen.

\subsection{Entwurf}


\subsection{Eingabeformat}
\subsubsection{Regeln}
Wird derzeit auf XML umgestellt.\\
\label{sec:Eingabedaten_Wir}
Regeln werden aus einer Textdatei eingelesen, in welcher zeilenweise die Regeln zu je einer Verbotsmenge stehen.
Die Datei besteht aus vier Spalten. In der Ersten sind die Namen der Verbote aufgelistet. In der Zweiten befinden sich die Regeln.
In der Dritten steht ein Schwellwert. In der Vierten steht ein Radius, der Anwendung findet, falls der Schwellwert überschritten wird.
Die Spalten werden durch eckige Klammern verdeutlicht und die einzelnen Regeln durch Kommata getrennt.
Die Trennung von Key und Value erfolgt durch einen Bindestrich.
Soll eine Regel generell für alle Values eines Keys gelten, so kann die Value weggelassen und nur der Key angegeben werden.

Eine Gültige Eingabe kann also folgendermaßen sein:
\begin{lstlisting}[frame=single]
[smoking="no"] -> [addr:housenumber -> 0.5, landuse - forest -> 1.5] -> [threshold:100.5] -> [radius:0.5]
[fishing="no", smoking="no"] -> [] -> [threshold:1000] -> [radius:2.1]
\end{lstlisting}
Dieses Regelwerk sagt aus, dass ein Nichtrauchen Verbot wahrscheinlich in Flächen gilt, welche eine Hausnummer zugewiesen haben
und sehr unwahrscheinlich in Gebieten, die als Waldgebiete ausgeschildert sind. 
Für das Angel- und Rauchverbot sind keine Regeln definiert. Unser Algorithmus wird sich also nur die nächstegelegene Fläche als wahrscheinlich nehmen,
oder sollten der Punkt innerhalb von 2 Flächen liegen\footnote{Es könnte z.B. eine Fläche 'Niedersachsen' und eine Fläche 'Waldgebiet' definiert sein.},
so wird die kleinere von beiden ausgewählt.

\textbf{Wichtig:} Es wird der Regelsatz angewendet, welche die größtmögliche Überlappung bei dem Verbotsmengen hat.
Sollte es also eine Verbotsmenge in den Daten geben, welche aus \begin{lstlisting}[frame=single]
smoking="no", food="no"
\end{lstlisting}
besteht, so wird das Regelwerk für smoking=''no'' angewendet. Um das explizit auszuschließen sind Verbotmengen mit leeren Regelmengen anzugeben
wie im Beispiel für Angel- und Rauchverbot getan.

\subsubsection{Daten}
\label{sec:Eingabedaten_GI}
Hier werden die aus der Aufgabenstellung übernommenen Regeln beachtet und das Eingabeformat wie beschrieben umgesetzt.
\begin{aquote}{GI Aufgabenstellung}
Die erste Zeile enthält die Anzahl $c$ der Space Usage Rules. Es folgen zeilenweise die Informationen
über die $c$ Regeldefinitionen.
Eine Zeile beginnt mit der ID der Space Usage Rule gefolgt von deren Position in geographischen
Koordinaten in der Form $Breitengrad, L"angengrad$. Als Eingabewerte sind für $Breitengrad$ und
$L"angengrad$ Fließkommazahlen mit einem ’.’ als Dezimaltrennzeichen erlaubt. Die einzelnen Informationen
sind durch Kommas und optionale Leerzeichen getrennt.
\end{aquote}

\subsection{Test}
Um die Qualität hoch zu halten werden für alle wichtigen Klassen und Methoden JUnit Tests
entworfen. Dabei ist das jeweils andere Teammitglied angehalten anhand der Dokumentation Blackbox-Test zu
schreiben um bei den Test unvoreingenommen zu sein und engagiert möglichst viele Fehler zu finden.

\subsection{Probleme}
Da die Berechnung der Schnittpolygone sehr aufwändig ist und wir nur eine Näherung benötigen,
wird die Berechnung der Schnittpolygone und deren Flächen vereinfach durch erstellen von Bounding Boxes.
Es wird also nicht das wirkliche Schnittpolygon berechnet, sondern die Schnitt Bounding Box, sowie die Fläche der Bounding Box.
